import base64
import os
import numpy as np
import pandas as pd
from flask import Flask, request, render_template, jsonify
from werkzeug.utils import secure_filename

app = Flask(__name__)
UPLOAD_FOLDER = 'uploads'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
if not os.path.exists(UPLOAD_FOLDER): os.makedirs(UPLOAD_FOLDER)

ALLOWED_EXTENSIONS = {'xlsx'}

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS


def load_sbox_from_excel(filepath):
    df = pd.read_excel(filepath, header=None)
    return df.values.flatten().astype(int).tolist()


def prepare_byte_sbox(sbox):
    if len(sbox) < 256:
        raise ValueError('S-Box harus memiliki minimal 256 entri untuk enkripsi gambar.')
    sbox_bytes = sbox[:256]
    if any(v < 0 or v > 255 for v in sbox_bytes):
        raise ValueError('Nilai S-Box untuk enkripsi gambar harus berada pada rentang 0-255.')
    if len(set(sbox_bytes)) != 256:
        raise ValueError('256 nilai pertama S-Box harus unik untuk membentuk inverse map.')
    inv = [0] * 256
    for i, v in enumerate(sbox_bytes):
        inv[v] = i
    return sbox_bytes, inv


def guess_mime_from_bytes(raw_bytes):
    # Simple magic-number based detection to avoid external deps
    if raw_bytes.startswith(b'\xff\xd8\xff'):
        return 'image/jpeg'
    if raw_bytes.startswith(b'\x89PNG\r\n\x1a\n'):
        return 'image/png'
    if raw_bytes.startswith(b'GIF87a') or raw_bytes.startswith(b'GIF89a'):
        return 'image/gif'
    if raw_bytes.startswith(b'BM'):
        return 'image/bmp'
    if raw_bytes.startswith(b'RIFF') and b'WEBP' in raw_bytes[:16]:
        return 'image/webp'
    return 'application/octet-stream'

# --- PNG UTILITIES FOR ENCRYPTED IMAGE ---

def _png_chunk(t, d):
    import struct, binascii
    return struct.pack('!I', len(d)) + t + d + struct.pack('!I', binascii.crc32(t + d) & 0xffffffff)

def make_png_from_bytes(data: bytes, width: int = 256, sbox_bytes: list[int] | None = None) -> bytes:
    """Wrap arbitrary bytes as a grayscale PNG for visualization.
    Stores original length in a tEXt chunk 'origlen' so decryption can trim.
    """
    import struct, zlib
    if width <= 0:
        width = 256
    width = min(4096, max(1, width))
    height = (len(data) + width - 1) // width
    # Build scanlines: filter byte 0 + row data padded to width
    scanlines = []
    idx = 0
    for _ in range(height):
        row = data[idx:idx+width]
        idx += width
        if len(row) < width:
            row += b'\x00' * (width - len(row))
        scanlines.append(b'\x00' + row)
    raw = b''.join(scanlines)
    compressed = zlib.compress(raw, 9)

    # IHDR: width, height, bit depth 8, color type 0 (grayscale), compression 0, filter 0, interlace 0
    ihdr = struct.pack('!IIBBBBB', width, height, 8, 0, 0, 0, 0)
    chunks = [
        _png_chunk(b'IHDR', ihdr),
        _png_chunk(b'tEXt', b'origlen\x00' + str(len(data)).encode('ascii')),
    ]
    if sbox_bytes is not None and len(sbox_bytes) >= 256:
        # Store first 256 S-Box values as comma-separated ASCII in tEXt chunk
        sbox_text = ','.join(str(int(v)) for v in sbox_bytes[:256]).encode('ascii')
        chunks.append(_png_chunk(b'tEXt', b'sbox256\x00' + sbox_text))
    chunks.append(_png_chunk(b'IDAT', compressed))
    chunks.append(_png_chunk(b'IEND', b''))
    png = b'\x89PNG\r\n\x1a\n' + b''.join(chunks)
    return png

def extract_bytes_from_png(png_bytes: bytes):
    """Extract raw bytes and embedded S-Box (if present) from PNG generated by make_png_from_bytes.
    Returns (data_bytes, sbox256_list or None).
    """
    import struct, zlib
    if not png_bytes.startswith(b'\x89PNG\r\n\x1a\n'):
        raise ValueError('Cipher file bukan PNG yang valid.')
    pos = 8
    width = height = None
    color_type = None
    idat = b''
    origlen = None
    sbox_list = None
    while pos + 8 <= len(png_bytes):
        length = struct.unpack('!I', png_bytes[pos:pos+4])[0]; pos += 4
        typ = png_bytes[pos:pos+4]; pos += 4
        data = png_bytes[pos:pos+length]; pos += length
        pos += 4  # skip CRC
        if typ == b'IHDR':
            width, height, bit_depth, color_type, comp, filt, inter = struct.unpack('!IIBBBBB', data)
        elif typ == b'tEXt':
            if data.startswith(b'origlen\x00'):
                try:
                    origlen = int(data[len(b'origlen\x00'):].decode('ascii'))
                except Exception:
                    pass
            elif data.startswith(b'sbox256\x00'):
                try:
                    txt = data[len(b'sbox256\x00'):].decode('ascii')
                    sbox_list = [int(x) for x in txt.split(',') if x.strip() != '']
                except Exception:
                    sbox_list = None
        elif typ == b'IDAT':
            idat += data
        elif typ == b'IEND':
            break
    if color_type != 0 or width is None or height is None:
        raise ValueError('Format PNG tidak didukung (harus grayscale 8-bit).')
    raw = zlib.decompress(idat)
    out = bytearray()
    off = 0
    for _ in range(height):
        if off >= len(raw):
            break
        filter_type = raw[off]; off += 1
        if filter_type != 0:
            raise ValueError('PNG memakai filter selain 0; tidak didukung.')
        row = raw[off:off+width]; off += width
        out.extend(row)
    if origlen is None:
        origlen = len(out)
    return bytes(out[:origlen]), sbox_list

# --- FUNGSI MATEMATIS KRIPTOGRAFI ---

def get_wht(a):
    n = len(a)
    if n == 1: return a
    a_left = get_wht(a[0:n//2])
    a_right = get_wht(a[n//2:n])
    res = np.zeros(n)
    res[0:n//2] = a_left + a_right
    res[n//2:n] = a_left - a_right
    return res

def test_nl_lap(S, N, n):
    all_nl = []
    max_bias = 0
    for j in range(1, N):
        fx = np.array([bin(int(j & S[x])).count('1') % 2 for x in range(N)])
        wht = get_wht(1 - 2 * fx)
        abs_wht = np.abs(wht)
        all_nl.append(2**(n-1) - 0.5 * np.max(abs_wht))
        max_bias = max(max_bias, np.max(abs_wht))
    return int(min(all_nl)), max_bias / (2 * N)

def test_du_dap(S, N):
    du_max = 0
    for delta_x in range(1, N):
        diff_y = S ^ S[np.arange(N, dtype=np.uint32) ^ delta_x]
        du_max = max(du_max, np.max(np.bincount(diff_y, minlength=N)))
    return int(du_max), du_max / N

def test_sac(S, N, n):
    sac_matrix = np.zeros((n, n))
    for i in range(n):
        diff_y = S ^ S[np.arange(N, dtype=np.uint32) ^ (1 << i)]
        for j in range(n):
            sac_matrix[i][j] = np.sum((diff_y >> j) & 1) / N
    return np.mean(sac_matrix)

def test_ci(S, N, n):
    final_ci = n
    for j in range(1, N):
        fx = np.array([bin(int(j & S[x])).count('1') % 2 for x in range(N)])
        wht = get_wht(1 - 2 * fx)
        curr_k = 0
        for alpha in range(1, N):
            if wht[alpha] != 0:
                hw = bin(alpha).count('1')
                curr_k = hw - 1 if curr_k == 0 else min(curr_k, hw - 1)
        final_ci = min(final_ci, curr_k)
    return int(final_ci)

# --- ROUTES ---

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/analyze_only', methods=['POST'])
def analyze_only():
    file = request.files.get('sbox_file')
    if not file: return jsonify({'success': False, 'message': 'File S-Box diperlukan'}), 400
    
    filename = secure_filename(file.filename)
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    file.save(filepath)

    try:
        df = pd.read_excel(filepath, header=None)
        sbox = df.values.flatten().astype(int).tolist()
        N = len(sbox)
        n = int(np.log2(N))
        S_np = np.array(sbox, dtype=np.uint32)

        # Hitung Properti
        nl, lap = test_nl_lap(S_np, N, n)
        du, dap = test_du_dap(S_np, N)
        sac = test_sac(S_np, N, n)
        ci = test_ci(S_np, N, n)

        nl_ideal = 2**(n-1) - 2**(n/2 - 1) if n % 2 == 0 else 2**(n-1) - 2**((n-1)/2)
        results = {
            "Non-Linearity (NL)": {"value": nl, "ideal": int(nl_ideal)},
            "Diff. Uniformity (DU)": {"value": du, "ideal": 4},
            "SAC (Avalanche)": {"value": round(sac, 4), "ideal": 0.5},
            "LAP (Linear Bias)": {"value": round(lap, 4), "ideal": round(1/np.sqrt(N), 4)},
            "DAP (Diff. Bias)": {"value": round(dap, 4), "ideal": round(4/N, 4)},
            "Algebraic Degree": {"value": n-1, "ideal": n-1},
            "Correlation Immunity": {"value": ci, "ideal": 0},
            "BIC-NL": {"value": nl - (n*2), "ideal": int(nl_ideal - 10)},
            "BIC-SAC": {"value": round(sac, 3), "ideal": 0.5}
        }
        return jsonify({'success': True, 'results': results, 'size': f"{N} ({n} bits)"})
    except Exception as e:
        return jsonify({'success': False, 'message': f"Gagal Analisis: {str(e)}"}), 500
    finally:
        if os.path.exists(filepath): os.remove(filepath)

@app.route('/encrypt_only', methods=['POST'])
def encrypt_only():
    file = request.files.get('sbox_file')
    plaintext = request.form.get('plaintext', '')
    if not file or not plaintext: 
        return jsonify({'success': False, 'message': 'File S-Box dan Teks diperlukan'}), 400

    filename = secure_filename(file.filename)
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    file.save(filepath)

    try:
        df = pd.read_excel(filepath, header=None)
        sbox = df.values.flatten().astype(int).tolist()
        N = len(sbox)
        
        # Proses Enkripsi Sederhana
        enc_list = [sbox[ord(c) % N] for c in plaintext]
        encrypted_text = ' '.join([format(x, '02X') for x in enc_list])
        
        # Proses Deskripsi Balik
        inv_sbox = [0] * N
        for i in range(N): inv_sbox[sbox[i]] = i
        decrypted_text = ''.join([chr(inv_sbox[x]) for x in enc_list])

        return jsonify({'success': True, 'encryption': encrypted_text, 'decryption': decrypted_text})
    except Exception as e:
        return jsonify({'success': False, 'message': f"Gagal Enkripsi: {str(e)}"}), 500
    finally:
        if os.path.exists(filepath): os.remove(filepath)


@app.route('/encrypt_image', methods=['POST'])
def encrypt_image():
    sbox_file = request.files.get('sbox_file')
    image_file = request.files.get('image_file')
    key = request.form.get('key', '')

    if not sbox_file or not image_file or not key:
        return jsonify({'success': False, 'message': 'S-Box, key, dan file gambar diperlukan'}), 400

    sbox_filename = secure_filename(sbox_file.filename)
    sbox_path = os.path.join(app.config['UPLOAD_FOLDER'], sbox_filename)
    sbox_file.save(sbox_path)

    try:
        sbox_raw = load_sbox_from_excel(sbox_path)
        sbox_bytes, _ = prepare_byte_sbox(sbox_raw)

        img_bytes = image_file.read()
        if not img_bytes:
            raise ValueError('File gambar kosong atau tidak dapat dibaca.')

        key_bytes = key.encode('utf-8')
        if not key_bytes:
            raise ValueError('Key tidak boleh kosong.')

        encrypted = bytearray(len(img_bytes))
        key_len = len(key_bytes)
        for i, b in enumerate(img_bytes):
            mapped = sbox_bytes[b]
            encrypted[i] = mapped ^ key_bytes[i % key_len]

        # Wrap ciphertext as PNG for visualization/download with embedded S-Box
        cipher_png = make_png_from_bytes(bytes(encrypted), width=256, sbox_bytes=sbox_bytes)
        cipher_b64 = base64.b64encode(cipher_png).decode('ascii')
        return jsonify({
            'success': True,
            'ciphertext': cipher_b64,
            'size': len(encrypted),
            'mime': 'image/png'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': f"Gagal Enkripsi Gambar: {str(e)}"}), 500
    finally:
        if os.path.exists(sbox_path): os.remove(sbox_path)


@app.route('/decrypt_image', methods=['POST'])
def decrypt_image():
    cipher_upload = request.files.get('cipher_file')
    ciphertext_b64 = request.form.get('ciphertext', '')
    key = request.form.get('key', '')

    if cipher_upload:
        ciphertext_b64 = base64.b64encode(cipher_upload.read()).decode('ascii')

    if not ciphertext_b64 or not key:
        return jsonify({'success': False, 'message': 'Key dan ciphertext (PNG/Base64) diperlukan'}), 400

    try:
        try:
            cipher_png_bytes = base64.b64decode(ciphertext_b64)
        except Exception:
            raise ValueError('Ciphertext tidak valid (bukan Base64).')

        # Extract encrypted bytes and S-Box from our PNG wrapper
        cipher_bytes, sbox_list = extract_bytes_from_png(cipher_png_bytes)
        if sbox_list is None or len(sbox_list) < 256:
            raise ValueError('PNG cipher tidak memuat S-Box. Gunakan hasil enkripsi dari aplikasi ini.')
        sbox_bytes = sbox_list[:256]
        inv_sbox = [0] * 256
        for i, v in enumerate(sbox_bytes):
            inv_sbox[v] = i
        valid_values = set(sbox_bytes)

        key_bytes = key.encode('utf-8')
        if not key_bytes:
            raise ValueError('Key tidak boleh kosong.')

        plaintext = bytearray(len(cipher_bytes))
        key_len = len(key_bytes)
        for i, c in enumerate(cipher_bytes):
            unmapped = c ^ key_bytes[i % key_len]
            if unmapped not in valid_values:
                raise ValueError('Ciphertext tidak sesuai dengan S-Box yang digunakan.')
            plaintext[i] = inv_sbox[unmapped]

        mime_guess = guess_mime_from_bytes(plaintext)
        plain_b64 = base64.b64encode(plaintext).decode('ascii')

        return jsonify({
            'success': True,
            'plaintext': plain_b64,
            'mime': mime_guess,
            'size': len(plaintext)
        })
    except Exception as e:
        return jsonify({'success': False, 'message': f"Gagal Dekripsi Gambar: {str(e)}"}), 500


if __name__ == '__main__':
    app.run(debug=True, port=5000)